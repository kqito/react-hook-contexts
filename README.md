# react-hook-contexts

![build status](https://github.com/kqito/react-hook-contexts/workflows/Node.js%20CI/badge.svg)
[![npm version](https://badge.fury.io/js/react-hook-contexts.svg)](https://badge.fury.io/js/react-hook-contexts)
![license](https://img.shields.io/github/license/kqito/react-hook-contexts)

Easy global state management for react using `useState` or `useReducer` with [context API](https://reactjs.org/docs/context.html).

## Features
- Easy state management with `useState` and `useReducer`.
- Generate multiple Contexts with the single function.
- Optimally split context to prevent unnecessary renders.
- `useSelector` function.

## Installation
You can install the package from npm.
```
npm install react-hook-contexts
```

or using yarn.
```
yarn add react-hook-contexts
```


## Usage
### General
```javascript
import React from "react";
import { createUseStateContexts } from "react-hook-contexts";

// You can add global state here. too easy !!
const [Contexts, ContextProviders] = createUseStateContexts({
  counter: 0,
  message: "",
  app: {
    name: "react-hook-contexts",
    description: "Easy global state management library",
  },
});

const App = () => {
  return (
    <ContextProviders>
      <AppName />
      <Counter />
      <CounterButton />
    </ContextProviders>
  );

  // To prevent unnecessary renders,
  // the context is automatically split in the virtual DOM as follows
  //
  // <CounterStateContext>
  //   <CounterDispatchContext>
  //     <MessageStateContext>
  //       <MessageDispatchContext>
  //         <AppStateContext>
  //           <AppDispatchContext>
  //             <AppName />
  //             <Counter />
  //             <CounterButton />
  //           </AppDispatchContext>
  //         </AppStateContext>
  //       </MessageDispatchContext>
  //     </MessageStateContext>
  //   </CounterDispatchContext>
  // </CounterStateContext>
};

const Counter = () => {
  // You can get the state value of the context as follows
  const counter = Contexts.counter.state();

  return <p>counter: {counter}</p>;
};

const CounterButton = () => {
  // It only gets the dispatch; separating the state and the dispatch prevents extra renders.
  const setCounter = Contexts.counter.dispatch();

  return (
    <>
      <button onClick={() => setCounter((counter) => counter + 1)}>+ 1</button>
      <button onClick={() => setCounter((counter) => counter - 1)}>- 1</button>
    </>
  );
};

const AppName = () => {
  // Like the redux useSelector API, you can retrieve only the state you need.
  // And there are no unnecessary renders.
  const name = Contexts.app.state((app) => app.name);

  return <p>App: {name}</p>;
};

export default App;
```


### `createUseStateContexts` API
  `createUseStateContexts` is generated by executing the values of the passed object as `useState` arguments, each of which is divided with appropriate granularity as a value of `context`.

```javascript
import React from "react";
import { createUseStateContexts } from "react-hook-contexts";

const [Contexts, ContextProviders] = createUseStateContexts({
  counter: 0,
  message: "",
  app: {
    name: "react-hook-contexts",
    description: "Easy global state management library",
  }
});
```

You can use it as follows.

```javascript
const appState = Contexts.app.state();
// {
//   name: "react-hook-contexts",
//   description: "Easy global state management library",
// }

const appName = Contexts.app.state(app => app.name)
// "react-hook-contexts"

const appDispatch = Contexts.app.dispatch()
// React.Dispatch<React.SetStateAction<AppState>>
```

### `createUseReducer` API
`createUseReducerContexts` is `createUseStateContexts` as well as generated by executing the values of the passed object as `useReducer` arguments, each of which is divided with appropriate granularity as a value of `context`.

```javascript
import React from "react";
import { createUseReducerContexts } from "react-hook-contexts";

const initialState = {
  count: 0,
};

const ActionType = {
  INCREMENT: "INCREMENT",
  DECREMENT: "DECREMENT",
} as const;

type CounterAction = {
  type: keyof typeof ActionType;
};

const reducer: React.Reducer<typeof initialState, CounterAction> = (
  state,
  action
) => {
  switch (action.type) {
    case ActionType.INCREMENT: {
      return {
        count: state.count + 1,
      };
    }

    case ActionType.DECREMENT: {
      return {
        count: state.count - 1,
      };
    }

    default: {
      return state;
    }
  }
};

export const [Contexts, ContextProviders] = createUseReducerContexts({
  counter: {
    reducer,
    initialState,
  },
  hogeCounter: {
    reducer,
    initialState,
  },
  hugeCounter: {
    reducer,
    initialState,
  },
});
```

The usage is the same as [`useCreateReducerContexts` API](https://github.com/kqito/react-hook-contexts/tree/feature/add-use-selector#createusestatecontexts-api).

## Examples
### [CreateUseStateContexts example](https://codesandbox.io/s/react-hook-contexts-examplecreateusestatecontexts-p5ug4 "CodeSandBox")
This is an example of a counter app that uses the `createUseStateContexts` API.

Notice that each time you increase/decrease the count, only the render of the Counter comport is running. (No unnecessary renders are happening.)


------------
### [CreateUseReducerContexts example](https://codesandbox.io/s/react-hook-contexts-examplecreateusereducercontexts-xfdxc?file=/src/App.tsx "CodeSandBox")
Similar to the example above, this is an example of a counter app using the `createUseReducerContexts` API.


------------

## License
[MIT Â© kqito](./LICENSE)
